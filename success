#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#define N 6
//哈曼夫树的存储结构
struct HuffNode{
    double weight;
    int lchild;
    int rchild;
    int parent;
};
typedef struct HuffNode HTNode;
typedef HTNode HuffmanT[2*N-1];

//构造编码模式
typedef struct{
    char ch;
    char bits[N+1];
}CodeNode;
typedef CodeNode HuffmanCode[N];

//构造字符+weight的模式
typedef struct{
    char ch;
    double weight;

}charAndWeight;
typedef charAndWeight cAndweight[N];

//建立堆栈
typedef charAndWeight element;
struct SNode{
    element data[N];
    int top;
};
typedef struct SNode *stack;


struct BTNode{
    int weight;
    char ch;
    BTNode *lchild;
    BTNode *rchild;
};
typedef struct BTNode *tree;

void CreatHT(HuffmanT T);//哈曼夫树的构造
void InitHT(HuffmanT T);//初始化结构
void InputW(HuffmanT T);//对权值进行赋值
void SelectMin(HuffmanT T,int m,int *p1,int *p2);//选取两个最小的权值
void CharSetHuffmanEncoding(HuffmanT T,HuffmanCode H,double *sum);//实现编码构造
void printfCode(HuffmanCode H);//打印编码
int CountformalL();//计算正常的编码长度
void read_sort(cAndweight C);//把字符和weight读进
void putIntoStack(cAndweight C);//建立最小堆
stack createStack();//创建堆栈
void push(stack s,element x);//压入堆栈
int IsstackEmpty(stack s);//判断堆栈是否为空
element pop(stack s);//弹出堆栈
int main()
{
    double sum=0;
    int m,j;
    cAndweight C;
    //HuffmanT T;
    //HuffmanCode H;
    //CreatHT(T);
    //CharSetHuffmanEncoding(T,H,&sum);//实现编码构造
    //printf("hh%d",H[2].bits[1]);//没有被定义的位置打印出来都是49，但是为什么打印bits一组的时候不会显示49
    //printfCode(H);
    //m=CountformalL();
    //printf("压缩率为：%lf\n",1-(sum/m));
    read_sort(C);
     putIntoStack(C);//建立最小堆
    //printf("%c\n",C[5].ch);
    //printf("%lf\n",C[1].weight);
    //s=createStack();

    return 0;
}

//哈曼夫树的构造
void CreatHT(HuffmanT T){
    int i,p1,p2;
    InitHT(T);//初始化结构
    InputW(T);//对权值进行赋值
    for(i=N;i<2*N-1;i++){
        SelectMin(T,i-1,&p1,&p2);
        T[p1].parent=T[p2].parent=i;//最小权值的两个结点的父亲都是i
        T[i].lchild=p1;//把i连接的左右儿子信息补全（覆盖修改parent=-1）
        T[i].rchild=p2;
        T[i].weight=T[p1].weight+T[p2].weight;//新节点为权值相加
    }
}

//初始化结构
void InitHT(HuffmanT T){
    int i;
    for(i=0;i<2*N-1;i++){
        T[i].parent=-1;
        T[i].lchild=-1;
        T[i].rchild=-1;
    }
}

//对权值进行赋值,权值是文本读进来的
void InputW(HuffmanT T){
    int i;
    double data;
    FILE *fp;
     if((fp=fopen("E://数据结构//作业2//frequencyAndChar.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(i=0;i<N;i++){
        fscanf(fp,"%lf\n",&data);
        T[i].weight=data;
    }
}

//选取两个最小的权值
void SelectMin(HuffmanT T,int m,int *p1,int *p2){
    int i,j;
    for(i=0;i<=m;i++){
        if(T[i].parent==-1){*p1=i;break; }//p1变成*p1
    }
    for(j=i+1;j<=m;j++)
        if(T[j].parent==-1){*p2=j;break; }

    for(i=0;i<=m;i++)
        if((T[*p1].weight>T[i].weight)&& (T[i].parent==-1) &&(*p2!=i) ) *p1=i;

    for(j=0;j<=m;j++)
        if((T[*p2].weight>T[j].weight)&& (T[j].parent==-1) &&(*p1!=j) ) *p2=j;
    printf("作为左儿子的编号p1:%d\n",*p1);
    printf("作为左儿子的编号p2:%d\n",*p2);
}


//实现编码构造
void CharSetHuffmanEncoding(HuffmanT T,HuffmanCode H,double *sum){
    int c,p,i,count;
    char cd[N+1];
    char ch_;
    int start;
    cd[N]='\0';
    FILE *fp;
     if((fp=fopen("E://数据结构//作业2//Char.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(i=0;i<N;i++){
        count=0;//重新清零
        fscanf(fp,"%c\n",&ch_);
        H[i].ch=ch_;
        start=N;
        c=i;
        while((p=T[c].parent)>=0){
        //p=T[c].parent;
        cd[--start]=((T[p].lchild==c)?'0':'1');
        count++;
        c=p;//继续往上找
        }
        *sum+=count*T[i].weight;
        printf("%lf\n",*sum);
        //把从cd[start]开始的地址且含有结束符的字符串复制到H[i]空间
        strcpy(H[i].bits,&cd[start]);
    }
}

//打印编码
void printfCode(HuffmanCode H){
    int i;
    for(i=0;i<N;i++){
        printf("%c %s",H[i].ch,H[i].bits);
        printf("\n");
    }
}

//计算正常的编码长度
int CountformalL(){
    int i;
    for(i=1;;i++){
        if(pow(2,i)>N)
            return i;
    }
}

//用堆栈实现哈曼夫编码

//把字符和weight读进
void read_sort(cAndweight C){
    int i,j;
    double temp;char temp_ch;
    FILE *fp;
     if((fp=fopen("E://数据结构//作业2//Char.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(i=0;i<N;i++){
        fscanf(fp,"%c\n",&C[i].ch);//读进字符
    }
    if((fp=fopen("E://数据结构//作业2//frequencyAndChar.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(j=0;j<N;j++){
        fscanf(fp,"%lf\n",&C[j].weight);//读进weight
    }
    //进行weight比较,从大到小排序
    for(i=0;i<N;i++){
        for(j=i+1;j<N;j++){
            if(C[i].weight<C[j].weight){
                temp=C[i].weight;
                temp_ch=C[i].ch;
                C[i].weight=C[j].weight;
                C[i].ch=C[j].ch;
                C[j].weight=temp;
                C[j].ch=temp_ch;
            }
        }
    }
    //检验是否正确排序
    /*
    for(j=0;j<N;j++){
        printf("%lf\n",C[j].weight);//读进weight
    }*/

}

//建立最小堆
void putIntoStack(cAndweight C){
    int j;
    stack s;
    s=createStack();
    for(j=0;j<N;j++){
        push(s,C[j]);
    }
}

//
voif combine(tree BT){
    int j;
    charAndWeight c1,c2;
    for(j=0;j<N;j++){
        BT=(tree)malloc(sizeof(struct BTNode));
        c1=pop(s);
        BT->lchild=(tree)malloc(sizeof(struct BTNode));
        BT->lchild->weight=c1.weight;
        BT->lchild->ch=c1.ch;
        c2=pop(s);
        BT->rchild=(tree)malloc(sizeof(struct BTNode));
        BT->rchild->weight=c2.weight;
        BT->rchild->ch=c2.ch;
        push(stack s,element x)
    }

}

//创建堆栈
stack createStack(){
    stack s=(stack)malloc(sizeof(struct SNode));
    s->top=-1;
    return s;
}

//压入堆栈
void push(stack s,element x)
{
    if(s->top==N-1){
        printf("full");
    }else{
        s->data[++(s->top)]=x;
    }
}

//判断堆栈是否为空
int IsstackEmpty(stack s){
    if(s->top==-1)
        return 1;
    else
        return 0;
}

//弹出堆栈
element pop(stack s){
   /* if(IsstackEmpty(s)){
        printf("堆栈是空的");
        return ERROR;
    }
    else
    {
        return (s->data[(s->top)--]);
    }*/
    return (s->data[(s->top)--]);
}
