#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#define N 6
//哈曼夫树的存储结构
struct HuffNode{
    double weight;
    int lchild;
    int rchild;
    int parent;
};
typedef struct HuffNode HTNode;
typedef HTNode HuffmanT[2*N-1];

//构造编码模式
typedef struct{
    char ch;
    char bits[N+1];
}CodeNode;
typedef CodeNode HuffmanCode[N];

//构造字符+weight的模式
typedef struct{
    char ch;
    double weight;

}charAndWeight;
typedef charAndWeight cAndweight[N];

struct BTNode{
    double weight;
    char ch;
    struct BTNode *lchild;
    struct BTNode *rchild;
};
typedef struct BTNode *tree;

//建立堆栈
typedef tree element;
struct SNode{
    element data[N];
    int top;
};
typedef struct SNode *stack;


void CreatHT(HuffmanT T);//哈曼夫树的构造
void InitHT(HuffmanT T);//初始化结构
void InputW(HuffmanT T);//对权值进行赋值
void SelectMin(HuffmanT T,int m,int *p1,int *p2);//选取两个最小的权值
void CharSetHuffmanEncoding(HuffmanT T,HuffmanCode H,double *sum);//实现编码构造
void printfCode(HuffmanCode H);//打印编码
int CountformalL();//计算正常的编码长度
void read_sort(cAndweight C);//把字符和weight读进
stack putIntoStack(cAndweight C);//建立最小堆
tree combine(tree BT,stack s);//多个树合并成一棵树
stack createStack();//创建堆栈
void push(stack s,element x);//压入堆栈
int IsstackEmpty(stack s);//判断堆栈是否为空
element pop(stack s);//弹出堆栈
void InmiddleTraversal(tree BT);//中序遍历
int main()
{
    //第一种方法：使用数组结构
    /*double sum=0;
    int m;
    HuffmanT T;
    HuffmanCode H;
    CreatHT(T);
    CharSetHuffmanEncoding(T,H,&sum);//实现编码构造
    //printf("hh%d",H[2].bits[1]);//没有被定义的位置打印出来都是49，但是为什么打印bits一组的时候不会显示49
    printfCode(H);
    m=CountformalL();
    printf("压缩率为：%lf\n",1-(sum/m));*/

    //第二种方法：使用堆栈,用中序遍历来打印树的信息，验证是否正确
    int i;
    cAndweight C;
    stack s;
    tree BT;
    BT=(tree)malloc(sizeof(struct BTNode));
    read_sort(C);
    s=putIntoStack(C);//建立最小堆
    //验证最小堆栈建立成功
    /*for(i=0;i<N;i++){
    BT=pop(s);
    printf("%c",BT->ch);
    }*/
    BT=combine(BT,s);//多个树合并成一棵树,BT是哈曼夫树的根节点
    //InmiddleTraversal(BT);//中序遍历来验证这棵树是否正确
    return 0;
}

//哈曼夫树的构造
void CreatHT(HuffmanT T){
    int i,p1,p2;
    InitHT(T);//初始化结构
    InputW(T);//对权值进行赋值
    for(i=N;i<2*N-1;i++){
        SelectMin(T,i-1,&p1,&p2);
        T[p1].parent=T[p2].parent=i;//最小权值的两个结点的父亲都是i
        T[i].lchild=p1;//把i连接的左右儿子信息补全（覆盖修改parent=-1）
        T[i].rchild=p2;
        T[i].weight=T[p1].weight+T[p2].weight;//新节点为权值相加
    }
}

//初始化结构
void InitHT(HuffmanT T){
    int i;
    for(i=0;i<2*N-1;i++){
        T[i].parent=-1;
        T[i].lchild=-1;
        T[i].rchild=-1;
    }
}

//对权值进行赋值,权值是文本读进来的
void InputW(HuffmanT T){
    int i;
    double data;
    FILE *fp;
     if((fp=fopen("E://数据结构//作业2//frequencyAndChar.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(i=0;i<N;i++){
        fscanf(fp,"%lf\n",&data);
        T[i].weight=data;
    }
}

//选取两个最小的权值
void SelectMin(HuffmanT T,int m,int *p1,int *p2){
    int i,j;
    for(i=0;i<=m;i++){
        if(T[i].parent==-1){*p1=i;break; }//p1变成*p1
    }
    for(j=i+1;j<=m;j++)
        if(T[j].parent==-1){*p2=j;break; }

    for(i=0;i<=m;i++)
        if((T[*p1].weight>T[i].weight)&& (T[i].parent==-1) &&(*p2!=i) ) *p1=i;

    for(j=0;j<=m;j++)
        if((T[*p2].weight>T[j].weight)&& (T[j].parent==-1) &&(*p1!=j) ) *p2=j;
    printf("作为左儿子的编号p1:%d\n",*p1);
    printf("作为左儿子的编号p2:%d\n",*p2);
}


//实现编码构造
void CharSetHuffmanEncoding(HuffmanT T,HuffmanCode H,double *sum){
    int c,p,i,count;
    char cd[N+1];
    char ch_;
    int start;
    cd[N]='\0';
    FILE *fp;
     if((fp=fopen("E://数据结构//作业2//Char.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(i=0;i<N;i++){
        count=0;//重新清零
        fscanf(fp,"%c\n",&ch_);
        H[i].ch=ch_;
        start=N;
        c=i;
        while((p=T[c].parent)>=0){
        //p=T[c].parent;
        cd[--start]=((T[p].lchild==c)?'0':'1');
        count++;
        c=p;//继续往上找
        }
        *sum+=count*T[i].weight;
        printf("%lf\n",*sum);
        //把从cd[start]开始的地址且含有结束符的字符串复制到H[i]空间
        strcpy(H[i].bits,&cd[start]);
    }
}

//打印编码
void printfCode(HuffmanCode H){
    int i;
    for(i=0;i<N;i++){
        printf("%c %s",H[i].ch,H[i].bits);
        printf("\n");
    }
}

//计算正常的编码长度
int CountformalL(){
    int i;
    for(i=1;;i++){
        if(pow(2,i)>N)
            return i;
    }
}

//把字符和weight读进
void read_sort(cAndweight C){
    int i,j;
    double temp;char temp_ch;
    FILE *fp;
     if((fp=fopen("E://数据结构//作业2//Char.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(i=0;i<N;i++){
        fscanf(fp,"%c\n",&C[i].ch);//读进字符
    }
    if((fp=fopen("E://数据结构//作业2//frequencyAndChar.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    for(j=0;j<N;j++){
        fscanf(fp,"%lf\n",&C[j].weight);//读进weight
    }
    //进行weight比较,从大到小排序
    for(i=0;i<N;i++){
        for(j=i+1;j<N;j++){
            if(C[i].weight<C[j].weight){
                temp=C[i].weight;
                temp_ch=C[i].ch;
                C[i].weight=C[j].weight;
                C[i].ch=C[j].ch;
                C[j].weight=temp;
                C[j].ch=temp_ch;
            }
        }
    }
    //检验是否正确排序
    /*
    for(j=0;j<N;j++){
        printf("%lf\n",C[j].weight);//读进weight
    }*/

}

//建立最小堆
stack putIntoStack(cAndweight C){
    int j;
    stack s;
    tree BT;
    s=createStack();
    for(j=0;j<N;j++){
        BT=(tree)malloc(sizeof(struct BTNode));
        BT->weight=C[j].weight;
        BT->ch=C[j].ch;
        push(s,BT);//是把tree结构的东西放进堆栈中
    }
    return s;
}

//多个树合并成一棵树
tree combine(stack s){
    int j;
    //这里是N-1！！！开始的时候写成了N
    for(j=0;j<N-1;j++){
        BT=(tree)malloc(sizeof(struct BTNode));
        BT->lchild=pop(s);
        BT->rchild=pop(s);
        BT->weight=BT->lchild->weight+BT->rchild->weight;
        BT->ch='#';
        //printf("%lf\n",BT->weight);打印出来观察对不对
        push(s,BT);
        //需要重新再建立最小堆
        biudSmallStack(s);
    }
    return pop(s);
}

//重新再建立最小堆
 biudSmallStack(stack s,){
    tree t;
    t=pop(s);
    if


}

//中序遍历
void InmiddleTraversal(tree BT){
    tree T;
    stack S=createStack();
    T=BT;
    while(T||!IsstackEmpty(S)){
        while(T){
        push(S,T);
        T=T->lchild;
        }
    T=pop(S);
    printf("%c",T->ch);
    T=T->rchild;
    }
}

//创建堆栈
stack createStack(){
    stack s=(stack)malloc(sizeof(struct SNode));
    s->top=-1;
    return s;
}

//压入堆栈
void push(stack s,element x)
{
    if(s->top==N-1){
        printf("full");
    }else{
        s->data[++(s->top)]=x;
    }
}

//判断堆栈是否为空
int IsstackEmpty(stack s){
    if(s->top==-1)
        return 1;
    else
        return 0;
}

//弹出堆栈
element pop(stack s){
   /* if(IsstackEmpty(s)){
        printf("堆栈是空的");
        return ERROR;
    }
    else
    {
        return (s->data[(s->top)--]);
    }*/
    return (s->data[(s->top)--]);
}
